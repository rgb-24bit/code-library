#+TITLE: JavaScript code snippet collection

* Table of Contents                                       :TOC_4_gh:noexport:
- [[#string-operation-related][String operation related]]
- [[#network-operation-related][Network operation related]]

* String operation related
  + Prevent filtering by adding characters of width 0 between characters
    #+BEGIN_SRC javascript
      f = (s) => Array.from(s).join('\u2061')
    #+END_SRC

  + Produces a function which uses template strings to do simple interpolation from objects
    #+BEGIN_SRC javascript
      /**
       ,* Produces a function which uses template strings to do simple interpolation from objects.
       ,*
       ,* Usage:
       ,*     var makeMeKing = generateTemplateString('${name} is now the king of ${country}!');
       ,*
       ,*     console.log(makeMeKing({ name: 'Bryan', country: 'Scotland'}));
       ,*     // Logs 'Bryan is now the king of Scotland!'
       ,*
       ,* Refrence:
       ,*     https://gist.github.com/bryanerayner/68e1498d4b1b09a30ef6
       ,*/
      const generateTemplateString = (function() {
        let cache = {};

        function generateTemplate(template) {
          let fn = cache[template];

          if (fn === undefined) {
            // Replace ${expressions} (etc) with ${map.expressions}.

            let sanitized = template
                .replace(/\$\{([\s]*[^;\s\{]+[\s]*)\}/g, function(_, match) {
                  return `\$\{map.${match.trim()}\}`;
                })

            // Afterwards, replace anything that's not ${map.expressions}' (etc) with a blank string.
                .replace(/(\$\{(?!map\.)[^}]+\})/g, '');

            fn = Function('map', `return \`${sanitized}\``);
          }
          return fn;
        };
        return generateTemplate;
      })();
    #+END_SRC

* Network operation related
  + Get the user IP throught the webkitRTCPeerConnection
    #+BEGIN_SRC javascript
      /**
       ,* Get the user IP throught the webkitRTCPeerConnection
       ,* @param onNewIP {Function} listener function to expose the IP locally
       ,* @return undefined
       ,*/
      function getUserIP(onNewIP) {  /* onNewIp - your listener function for new IPs */
        /* compatibility for firefox and chrome */
        var myPeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection;
        var pc = new myPeerConnection({
          iceServers: []
        }),
            noop = function() {},
            localIPs = {},
            ipRegex = /([0-9]{1,3}(\.[0-9]{1,3}){3}|[a-f0-9]{1,4}(:[a-f0-9]{1,4}){7})/g,
            key;

        function iterateIP(ip) {
          if (!localIPs[ip]) onNewIP(ip);
          localIPs[ip] = true;
        }

        /* create a bogus data channel */
        pc.createDataChannel("");

        /*  create offer and set local description */
        pc.createOffer().then(function(sdp) {
          sdp.sdp.split('\n').forEach(function(line) {
            if (line.indexOf('candidate') < 0) return;
            line.match(ipRegex).forEach(iterateIP);
          });

          pc.setLocalDescription(sdp, noop, noop);
        }).catch(function(reason) {
          /*  An error occurred, so handle the failure to connect */
        });

        /* listen for candidate events */
        pc.onicecandidate = function(ice) {
          if (!ice || !ice.candidate || !ice.candidate.candidate || !ice.candidate.candidate.match(ipRegex)) return;
          ice.candidate.candidate.match(ipRegex).forEach(iterateIP);
        };
      }
    #+END_SRC
    
    Use like this:
    #+BEGIN_SRC javascript
      getUserIP(function(ip) {
        alert("Got IP! :" + ip);
      });
    #+END_SRC
